"""
내 질문 1:
    내가 주식 거래를 쉽게 하기 위해 프로그램을 작성하고 있어.
    누구나 간단한 스크립트 명령으로 주식이나 선물 옵션 거래를 할 수 있도록 기능을 구현하고 있어.
    예를 들어 "order 매수 '000660' 20 1000" 이렇게 명령을 주면
    000660 이라는 주식을 1000원에 20 주에 사겠다는 주문을 내는 거다.
    그런데 선물 옵션의 경우 변동성이 너무 커서 일반인들에게 공개하는 것이 적절한지 모르겠어.
    너무 쉽게 거래가 가능하기 때문에 손실을 크게 입을 수도 있거든. 어떻게 하는 것이 좋을까?

Bard 답변 1:
    선물 옵션은 변동성이 크고 손실 위험이 높은 상품이기 때문에,
    일반인에게 공개하는 것이 적절하지 않을 수 있습니다.
    다음과 같은 방법을 고려해 볼 수 있습니다.

        선물 옵션 거래를 위해서는 별도의 교육을 이수한 후, 일정 금액 이상의 증거금을 예치하도록 합니다.
            이를 통해 선물 옵션 거래에 대한 이해와 위험에 대한 인식을 높이고, 손실 위험을 최소화할 수 있습니다.
        선물 옵션 거래를 위해서는 별도의 인증을 받도록 합니다.
            이를 통해 선물 옵션 거래에 대한 기본적인 지식과 경험을 갖춘 사람만 거래를 할 수 있도록 합니다.
        선물 옵션 거래를 위해서는 별도의 제한을 두도록 합니다.
            예를 들어, 선물 옵션 거래의 한도를 제한하거나, 손실이 발생할 경우 손실액을 제한하는 등의 방법이 있습니다.

    구체적인 방법은 프로그램의 용도와 목표, 사용자 대상 등을 고려하여 결정해야 합니다.
    예를 들어, 프로그램이 주식 거래를 주로 하는 일반인을 대상으로 한다면,
    선물 옵션 거래 기능을 제외하거나, 별도의 교육 및 인증을 요구하는 방법을 고려할 수 있습니다.
    반면, 프로그램이 선물 옵션 거래 전문가를 대상으로 한다면,
    별도의 제한을 두지 않고 모든 기능을 제공하는 방법을 고려할 수 있습니다.
    또한, 프로그램에 선물 옵션 거래의 위험성을 경고하는 문구를 표시하거나,
    선물 옵션 거래에 대한 정보를 제공하는 기능을 추가하는 것도 도움이 될 수 있습니다.

ChartGPT 답변 1:
    주식이나 선물 옵션 거래와 같은 금융 상품에 대한 알고리즘 트레이딩 시스템을 개발하고
    누구나 쉽게 사용할 수 있게 하기 전에 몇 가지 고려해야 할 사항이 있습니다.
    특히 일반 사용자에게 금융 상품에 대한 쉬운 접근은 부작용을 초래할 수 있습니다.

        리스크 경고 및 교육:
            프로그램을 사용하는 사용자에게 금융 상품에 대한 기본 지식을 제공하고
            리스크에 대한 경고를 표시하는 것이 중요합니다.
            거래에 따르는 잠재적인 손실을 이해하지 못한 채로 거래하는 것은 위험합니다.

        자동화 거래 제한:
            일반인들이 자동화된 거래 시스템을 사용할 때,
            금융 시장에서의 급격한 움직임에 대응하기 어려워 손실을 크게 입을 수 있습니다.
            거래의 빈도를 제한하거나 특정한 상황에서만 거래를 허용하는 기능을 추가하여 제어할 수 있습니다.

        금융 규제 준수:
            금융 시장에서 거래를 하려면 해당 국가 또는 지역의 금융 규제를 준수해야 합니다.
            사용자들이 합법적이고 안전한 거래를 할 수 있도록 규제를 준수하는 것이 중요합니다.

        테스트와 시뮬레이션:
            사용자가 프로그램을 사용하기 전에 실제 돈을 투자하지 않고도 시뮬레이션 환경에서
            거래를 테스트할 수 있는 기능을 추가하는 것이 좋습니다.
            이를 통해 사용자들은 시스템의 동작을 확인하고 전략을 개발할 수 있습니다.

        사용자 인증 및 보안:
            민감한 금융 거래에 대한 접근을 통제하기 위해 강력한 사용자 인증 및 보안 기능을 추가하세요.
            또한 사용자의 개인정보와 거래 데이터를 안전하게 저장하고 처리하는 것이 중요합니다.

        커뮤니티 지원:
            사용자 간의 경험 공유 및 지원을 위한 커뮤니티를 구축하면
            사용자 간의 지식 교류와 서로에게 도움이 될 수 있습니다.

    주식이나 선물 옵션 거래는 높은 리스크와 보안 문제를 포함하고 있으므로,
    신중하게 설계하고 안전한 사용을 보장하는 것이 중요합니다.

===============================================================================

내 질문 2:
    내가 주식 거래를 쉽게 하기 위해 프로그램을 작성하고 있어.
    누구나 간단한 스크립트 명령으로 주식이나 선물 옵션 거래를 할 수 있도록 기능을 구현하고 있어.
    예를 들어 "order 매수 '000660' 20 1000" 이렇게 명령을 주면
    000660 이라는 주식을 1000원에 20 주에 사겠다는 주문을 내는 거다.
    무척 편리한 기능으로 이런 방식으로 선물 옵션등의 파생상품 거래를 쉽게 사용할 수 있어.
    일반 투자자에게 이런 기능을 공개하는 것은 어떨까?


Bard 답변 2:
    일반 투자자에게 이런 기능을 공개하는 것은 좋은 아이디어라고 생각합니다.
    주식 거래를 쉽게 할 수 있도록 하는 것은 투자자들이 시장에서
    더 많은 기회를 얻을 수 있도록 하는 데 도움이 될 수 있습니다.
    또한, 파생상품 거래는 더 복잡하고 위험할 수 있지만,
    일반 투자자들에게도 유용할 수 있는 도구가 될 수 있습니다.

    물론, 선물 옵션 거래의 위험성을 고려하여 적절한 제한을 두는 것이 중요합니다.
    예를 들어, 선물 옵션 거래를 위해서는 별도의 교육을 이수한 후,
    일정 금액 이상의 증거금을 예치하도록 하는 등의 방법을 고려할 수 있습니다.
    또한, 프로그램에 선물 옵션 거래의 위험성을 경고하는 문구를 표시하거나,
    선물 옵션 거래에 대한 정보를 제공하는 기능을 추가하는 것도 도움이 될 수 있습니다.

    다음은 일반 투자자에게 선물 옵션 거래 기능을 공개할 때 고려해야 할 몇 가지 사항입니다.

        교육 및 인증: 선물 옵션 거래에 대한 이해와 위험에 대한 인식을 높이기 위해,
            교육 및 인증을 요구하는 방법을 고려할 수 있습니다.
        제한: 선물 옵션 거래의 한도를 제한하거나,
            손실이 발생할 경우 손실액을 제한하는 등의 방법을 고려할 수 있습니다.
        위험성 경고: 프로그램에 선물 옵션 거래의 위험성을 경고하는 문구를 표시하거나,
            선물 옵션 거래에 대한 정보를 제공하는 기능을 추가하는 것도 도움이 될 수 있습니다.

    이러한 사항을 고려하여 적절한 제한을 두고 선물 옵션 거래 기능을 공개한다면,
    일반 투자자들도 안전하고 효율적으로 파생상품 거래를 할 수 있을 것입니다.

ChartGPT 답변 2:
    일반 투자자에게 주식이나 파생상품 거래를 쉽게 할 수 있는 프로그램을 공개하는 것은
    여러 측면에서 고려해야 할 중요한 문제들이 있습니다. 아래는 몇 가지 주요 고려 사항입니다:

        금융 규제 및 법률 준수:
            금융 상품 거래와 관련된 프로그램을 공개하려면 해당 국가
            또는 지역의 금융 규제 및 법률을 준수해야 합니다.
            특히 주식이나 파생상품 거래는 규제가 엄격하므로,
            이를 준수하지 않으면 법적 문제가 발생할 수 있습니다.

        리스크 경고 및 교육:
            사용자가 금융 상품에 대한 거래를 할 때 리스크를 충분히 이해하도록 경고하고,
            필요한 교육 자료를 제공하는 것이 중요합니다.
            거래는 항상 손실의 가능성이 있으므로 사용자가 책임감 있게 투자할 수 있도록 유도해야 합니다.

        보안 및 개인정보 보호:
            금융 거래와 관련된 프로그램은 민감한 정보를 다루므로
            강력한 보안 및 개인정보 보호 조치가 필요합니다.
            사용자의 개인정보와 거래 데이터를 안전하게 저장하고 처리하는 것이 중요합니다.

        자동화 거래 제한:
            사용자가 자동화된 거래 시스템을 사용할 때 일종의 자동화 제한을 두어
            너무 높은 레버리지나 과도한 거래 빈도로 인한 손실을 방지할 필요가 있습니다.

        사용자 지원 및 교육:
            사용자가 프로그램을 올바르게 이해하고 사용할 수 있도록 지원 및 교육을 제공하는 것이 중요합니다.
            온라인 커뮤니티나 도움말 섹션을 통해 사용자 간의 경험 공유와 도움을 주고 받을 수 있는 환경을 마련해야 합니다.

        커뮤니케이션 및 투명성:
            프로그램의 작동 방식과 거래 전략에 대한 투명성을 유지하고,
            사용자들에게 실시간으로 정보를 전달하여 투자 결정을 내릴 때 참고 자료를 제공해야 합니다.

    금융 서비스를 제공하는 것은 높은 책임을 수반하므로 신중한 계획과 적절한 준비가 필요합니다.
    이를테면, 초기에는 제한된 범위에서 시작하여 사용자들의 피드백을 수용하고 서비스를 개선해 나가는 것이 좋습니다.

==================================================================================
결론 :
    위 답변을 참고하여 파생 거래에 대한 기능은 공개하지 않도록 한다.
"""

from abc import abstractmethod


class Session:
    def __init__(self, parent):
        self._c = parent.config
        self._q = parent.queue
        self._t = parent.telegram
        self._a = None
        self._match = parent.match

    @property
    def config(self) -> object:
        return self._c

    def _exception(self, msg_):
        self._t.send_msg(msg_)
        raise Exception(msg_)

    def _w_msg(self, f: str, p: str) -> str:
        return f"{self.__class__.__name__}.{f} > {p}"

    def __is_stock(self, a_id) -> bool:
        return self._a[a_id].a_type == 'stock'

    @abstractmethod
    def _st_load_balance(self, a_id) -> list:
        pass

    @abstractmethod
    def _fo_load_balance(self, a_id) -> list:
        pass

    def load_balance(self, a_id) -> list:
        return self._st_load_balance(a_id) if self.__is_stock(a_id) else self._fo_load_balance(a_id)

    @abstractmethod
    def _st_matching_items(self, a_id) -> list:
        pass

    @abstractmethod
    def _fo_matching_items(self, a_id) -> list:
        pass

    def matching_items(self, a_id) -> list:
        return self._st_matching_items(a_id) if self.__is_stock(a_id) else self._fo_matching_items(a_id)

    @abstractmethod
    def logout(self):
        pass

    @abstractmethod
    def stop(self):
        pass

    @abstractmethod
    def cur_price(self, code) -> int | float:
        pass

    @abstractmethod
    def buy_price(self, code) -> int | float:
        pass

    @abstractmethod
    def sell_price(self, code) -> int | float:
        pass

    @abstractmethod
    def order(self, a_id, mode, code, qty, price):
        pass

    @abstractmethod
    def modify(self, a_id, mode, code, qty, price, org_order_no):
        pass

    @abstractmethod
    def cancel(self, a_id, mode, code, qty, org_order_no):
        pass
